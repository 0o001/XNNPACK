// Copyright 2021 Google LLC
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$assert BATCH_TILE >= 1
#include <assert.h>

#include <xnnpack/math.h>
#include <xnnpack/vadd.h>


void xnn_qs8_vadd_minmax_ukernel__scalar_x${BATCH_TILE}(
    size_t n,
    const int8_t* input_a,
    const int8_t* input_b,
    int8_t* output,
    const union xnn_qs8_add_minmax_params params[restrict XNN_MIN_ELEMENTS(1)]) XNN_DISABLE_TSAN
{
  const int32_t vbias = params->scalar.bias;
  const int32_t va_multiplier = params->scalar.a_multiplier;
  const int32_t vb_multiplier = params->scalar.b_multiplier;
  const int32_t vrounding = params->scalar.rounding;
  const uint32_t vshift = params->scalar.shift;
  const int32_t voutput_min_less_zero_point = params->scalar.output_min_less_zero_point;
  const int32_t voutput_max_less_zero_point = params->scalar.output_max_less_zero_point;
  const int32_t voutput_zero_point = params->scalar.output_zero_point;

  $if BATCH_TILE == 1:
    do {
      const int32_t va = *input_a++;
      const int32_t vb = *input_b++;
      const int32_t vacc = vbias + va * va_multiplier + vb * vb_multiplier;

      int32_t vout = asr_s32(vacc + asr_s32(vacc, 31) + vrounding, vshift);
      vout = math_max_s32(vout, voutput_min_less_zero_point);
      vout = math_min_s32(vout, voutput_max_less_zero_point);
      *output++ = (int8_t) (vout + voutput_zero_point);

      n -= sizeof(int8_t);
    } while (n != 0);
  $else:
    for (; n >= ${BATCH_TILE} * sizeof(int8_t); n -= ${BATCH_TILE} * sizeof(int8_t)) {
      $for N in range(BATCH_TILE):
        const int32_t va${N} = input_a[${N}];
      input_a += ${BATCH_TILE};

      $for N in range(BATCH_TILE):
        const int32_t vb${N} = input_b[${N}];
        int32_t vacc${N} = vbias + va${N} * va_multiplier;
      input_b += ${BATCH_TILE};

      $for N in range(BATCH_TILE):
        vacc${N} += vb${N} * vb_multiplier;

      $for N in range(BATCH_TILE):
        int32_t vout${N} = asr_s32(vacc${N} + asr_s32(vacc${N}, 31) + vrounding, vshift);

      $for N in range(BATCH_TILE):
        vout${N} = math_max_s32(vout${N}, voutput_min_less_zero_point);

      $for N in range(BATCH_TILE):
        vout${N} = math_min_s32(vout${N}, voutput_max_less_zero_point);

      $for N in range(BATCH_TILE):
        vout${N} += voutput_zero_point;

      $for N in range(BATCH_TILE):
        output[${N}] = vout${N};
      output += ${BATCH_TILE};
    }
    if XNN_UNLIKELY(n != 0) {
      $if BATCH_TILE == 2:
        const int32_t va = *input_a;
        const int32_t vb = *input_b;
        const int32_t vacc = vbias + va * va_multiplier + vb * vb_multiplier;

        int32_t vout = asr_s32(vacc + asr_s32(vacc, 31) + vrounding, vshift);
        vout = math_max_s32(vout, voutput_min_less_zero_point);
        vout = math_min_s32(vout, voutput_max_less_zero_point);
        *output++ = (int8_t) (vout + voutput_zero_point);
      $else:
        do {
          const int32_t va = *input_a++;
          const int32_t vb = *input_b++;
          const int32_t vacc = vbias + va * va_multiplier + vb * vb_multiplier;

          int32_t vout = asr_s32(vacc + asr_s32(vacc, 31) + vrounding, vshift);
          vout = math_max_s32(vout, voutput_min_less_zero_point);
          vout = math_min_s32(vout, voutput_max_less_zero_point);
          *output++ = (int8_t) (vout + voutput_zero_point);

          n -= sizeof(int8_t);
        } while (n != 0);
    }
}
