// Copyright 2021 Google LLC
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$assert CHANNEL_TILE >= 1
$assert CHANNEL_TILE <= 16
$assert ROW_TILE >= 2
$assert ROW_SUBTILE >= 2
$assert ROW_SUBTILE <= ROW_TILE
$assert ACCUMULATORS >= 1
$assert ROW_TILE >= ACCUMULATORS * 2
$assert ROW_SUBTILE >= ACCUMULATORS * 2
$assert REQUANTIZATION == "FP32"
#include <assert.h>
$if VARIANT == "LRINTF":
  #include <math.h>
$elif VARIANT in ["FMAGIC", "IMAGIC"]:

  #include <fp16.h>

#include <xnnpack/gavgpool.h>
#include <xnnpack/math.h>


$PARAMS_STRUCT = "fp32_scalar_" + VARIANT.lower()
void xnn_qs8_gavgpool_minmax_ukernel_${ROW_TILE}p${ROW_SUBTILE}x__scalar_c${CHANNEL_TILE}${"" if ACCUMULATORS == 1 else "_acc%d" % ACCUMULATORS}(
    size_t rows,
    size_t channels,
    const int8_t* input,
    size_t input_stride,
    const int8_t* zero,
    int32_t* buffer,
    int8_t* output,
    const union xnn_qs8_avgpool_minmax_params params[restrict XNN_MIN_ELEMENTS(1)])
{
  assert(rows > ${ROW_TILE});
  assert(channels != 0);

  const int8_t* i0 = input;
  $for M in range(1, ROW_TILE):
    const int8_t* i${M} = (const int8_t*) ((uintptr_t) i${M-1} + input_stride);
  $if CHANNEL_TILE <= 16:
    const size_t input_increment = ${ROW_TILE} * input_stride - round_up_po2(channels, ${CHANNEL_TILE});
  $else:
    const size_t input_increment = ${ROW_TILE} * input_stride - round_up_po2(channels, 8);

  const int32_t vinit_bias = params->${PARAMS_STRUCT}.init_bias;
  int32_t* b = buffer;
  $if CHANNEL_TILE == 1:
    size_t c = channels;
    do {
      $for M in range(ROW_TILE):
        const int32_t vi${M} = *i${M}++;

      $for A in range(ACCUMULATORS):
        int32_t vacc${A} = vi${A*2} + vi${A*2+1};

      $for M in range(ACCUMULATORS * 2, ROW_TILE):
        vacc${M % ACCUMULATORS} += vi${M};

      $if ACCUMULATORS > 1:
        $ACC_SLICE = 1
        $while ACC_SLICE < ACCUMULATORS:
          $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
            $if A + ACC_SLICE < ACCUMULATORS:
              vacc${A} += vacc${A + ACC_SLICE};
          $ACC_SLICE *= 2

      const int32_t vacc = vinit_bias + vacc0;
      *b++ = vacc;
    } while (--c != 0);
  $else:
    for (ptrdiff_t c = (ptrdiff_t) channels; c > 0; c -= ${CHANNEL_TILE}) {
      $for M in range(ROW_TILE):
        $for C in range(CHANNEL_TILE):
          const int32_t vi${M}x${C} = i${M}[${C}];
        i${M} += ${CHANNEL_TILE};

      $for A in range(ACCUMULATORS):
        $for C in range(CHANNEL_TILE):
          int32_t vacc${A}x${C} = vi${A*2}x${C} + vi${A*2+1}x${C};

      $for M in range(ACCUMULATORS * 2, ROW_TILE):
        $for C in range(CHANNEL_TILE):
          vacc${M % ACCUMULATORS}x${C} += vi${M}x${C};

      $if ACCUMULATORS > 1:
        $ACC_SLICE = 1
        $while ACC_SLICE < ACCUMULATORS:
          $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
            $if A + ACC_SLICE < ACCUMULATORS:
              $for C in range(CHANNEL_TILE):
                vacc${A}x${C} += vacc${A + ACC_SLICE}x${C};
          $ACC_SLICE *= 2

      $for C in range(CHANNEL_TILE):
        const int32_t vacc${C} = vinit_bias + vacc0x${C};

      $for C in range(CHANNEL_TILE):
        b[${C}] = vacc${C};
      b += ${CHANNEL_TILE};
    }

  for (rows -= ${ROW_TILE}; rows > ${ROW_SUBTILE}; rows -= ${ROW_SUBTILE}) {
    $for M in range(ROW_SUBTILE):
      i${M} = (const int8_t*) ((uintptr_t) i${M + ROW_TILE - ROW_SUBTILE} + input_increment);

    int32_t* b = buffer;
    $if CHANNEL_TILE == 1:
      size_t c = channels;
      do {
        $for M in range(ROW_SUBTILE):
          const int32_t vi${M} = *i${M}++;

        $for A in range(ACCUMULATORS):
          int32_t vacc${A} = vi${A*2} + vi${A*2+1};

        $for M in range(ACCUMULATORS * 2, ROW_SUBTILE):
          vacc${M % ACCUMULATORS} += vi${M};

        $if ACCUMULATORS > 1:
          $ACC_SLICE = 1
          $while ACC_SLICE < ACCUMULATORS:
            $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
              $if A + ACC_SLICE < ACCUMULATORS:
                vacc${A} += vacc${A + ACC_SLICE};
            $ACC_SLICE *= 2

        int32_t vacc = *b + vacc0;
        *b++ = vacc;
      } while (--c != 0);
    $else:
      for (ptrdiff_t c = (ptrdiff_t) channels; c > 0; c -= ${CHANNEL_TILE}) {
        $for M in range(ROW_SUBTILE):
          $for C in range(CHANNEL_TILE):
            const int32_t vi${M}x${C} = i${M}[${C}];
          i${M} += ${CHANNEL_TILE};

        $for A in range(ACCUMULATORS):
          $for C in range(CHANNEL_TILE):
            int32_t vacc${A}x${C} = vi${A*2}x${C} + vi${A*2+1}x${C};

        $for M in range(ACCUMULATORS * 2, ROW_SUBTILE):
          $for C in range(CHANNEL_TILE):
            vacc${M % ACCUMULATORS}x${C} += vi${M}x${C};

        $if ACCUMULATORS > 1:
          $ACC_SLICE = 1
          $while ACC_SLICE < ACCUMULATORS:
            $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
              $if A + ACC_SLICE < ACCUMULATORS:
                $for C in range(CHANNEL_TILE):
                  vacc${A}x${C} += vacc${A + ACC_SLICE}x${C};
            $ACC_SLICE *= 2

        $for C in range(CHANNEL_TILE):
          int32_t vacc${C} = b[${C}] + vacc0x${C};

        $for C in range(CHANNEL_TILE):
          b[${C}] = vacc${C};
        b += ${CHANNEL_TILE};
      }
  }

  i0 = (const int8_t*) ((uintptr_t) i${ROW_TILE - ROW_SUBTILE} + input_increment);
  $for M in range(1, ROW_SUBTILE):
    i${M} = (const int8_t*) ((uintptr_t) i${M + ROW_TILE - ROW_SUBTILE} + input_increment);
    $if M % 2 == 1:
      if XNN_UNPREDICTABLE(rows < ${M+1}) {
        i${M} = zero;
      }
    $else:
      if XNN_UNPREDICTABLE(rows <= ${M}) {
        i${M} = zero;
      }

  const float vscale = params->${PARAMS_STRUCT}.scale;
  $if VARIANT == "FMAGIC":
    const float voutput_min_less_zero_point = params->fp32_scalar_fmagic.output_min_less_zero_point;
    const float voutput_max_less_zero_point = params->fp32_scalar_fmagic.output_max_less_zero_point;
    const float vmagic_bias = params->fp32_scalar_fmagic.magic_bias;
    const int32_t vmagic_bias_less_output_zero_point = params->fp32_scalar_fmagic.magic_bias_less_output_zero_point;
  $elif VARIANT == "IMAGIC":
    const float vmagic_bias = params->fp32_scalar_imagic.magic_bias;
    const int32_t vmagic_min = params->fp32_scalar_imagic.magic_min;
    const int32_t vmagic_max = params->fp32_scalar_imagic.magic_max;
    const int32_t vmagic_bias_less_zero_point = params->fp32_scalar_imagic.magic_bias_less_zero_point;
  $elif VARIANT == "LRINTF":
    const float voutput_min_less_zero_point = params->fp32_scalar_lrintf.output_min_less_zero_point;
    const float voutput_max_less_zero_point = params->fp32_scalar_lrintf.output_max_less_zero_point;
    const int32_t voutput_zero_point = params->fp32_scalar_lrintf.output_zero_point;
  $if CHANNEL_TILE == 1:
    do {
      $for M in range(ROW_SUBTILE):
        const int32_t vi${M} = *i${M}++;

      $for A in range(ACCUMULATORS):
        int32_t vacc${A} = vi${A*2} + vi${A*2+1};

      $for M in range(ACCUMULATORS * 2, ROW_SUBTILE):
        vacc${M % ACCUMULATORS} += vi${M};

      $if ACCUMULATORS > 1:
        $ACC_SLICE = 1
        $while ACC_SLICE < ACCUMULATORS:
          $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
            $if A + ACC_SLICE < ACCUMULATORS:
              vacc${A} += vacc${A + ACC_SLICE};
          $ACC_SLICE *= 2

      const int32_t vacc = (*buffer++) + vacc0;
      float vfpacc = (float) vacc * vscale;

      $if VARIANT == "FMAGIC":
        vfpacc = ${MAX_F32}(vfpacc, voutput_min_less_zero_point);
        vfpacc = ${MIN_F32}(vfpacc, voutput_max_less_zero_point);
        vfpacc += vmagic_bias;
        int32_t vout = (int32_t) fp32_to_bits(vfpacc) - vmagic_bias_less_output_zero_point;
      $elif VARIANT == "IMAGIC":
        vfpacc += vmagic_bias;
        int32_t vout = (int32_t) fp32_to_bits(vfpacc);
        vout = math_max_s32(vout, vmagic_min);
        vout = math_min_s32(vout, vmagic_max);
        vout -= vmagic_bias_less_zero_point;
      $elif VARIANT == "LRINTF":
        vfpacc = ${MAX_F32}(vfpacc, voutput_min_less_zero_point);
        vfpacc = ${MIN_F32}(vfpacc, voutput_max_less_zero_point);
        const int32_t vrndacc = (int32_t) lrintf(vfpacc);
        int32_t vout = vrndacc + voutput_zero_point;

      *output++ = (int8_t) vout;
    } while (--channels != 0);
  $else:
    for (; channels >= ${CHANNEL_TILE}; channels -= ${CHANNEL_TILE}) {
      $for M in range(ROW_SUBTILE):
        $for C in range(CHANNEL_TILE):
          const int32_t vi${M}x${C} = i${M}[${C}];
        i${M} += ${CHANNEL_TILE};

      $for A in range(ACCUMULATORS):
        $for C in range(CHANNEL_TILE):
          int32_t vacc${A}x${C} = vi${A*2}x${C} + vi${A*2+1}x${C};

      $for M in range(ACCUMULATORS * 2, ROW_SUBTILE):
        $for C in range(CHANNEL_TILE):
          vacc${M % ACCUMULATORS}x${C} += vi${M}x${C};

      $if ACCUMULATORS > 1:
        $ACC_SLICE = 1
        $while ACC_SLICE < ACCUMULATORS:
          $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
            $if A + ACC_SLICE < ACCUMULATORS:
              $for C in range(CHANNEL_TILE):
                vacc${A}x${C} += vacc${A + ACC_SLICE}x${C};
          $ACC_SLICE *= 2

      $for C in range(CHANNEL_TILE):
        const int32_t vacc${C} = buffer[${C}] + vacc0x${C};
      buffer += ${CHANNEL_TILE};

      $for C in range(CHANNEL_TILE):
        float vfpacc${C} = (float) vacc${C} * vscale;

      $if VARIANT == "FMAGIC":
        $for C in range(CHANNEL_TILE):
          vfpacc${C} = ${MAX_F32}(vfpacc${C}, voutput_min_less_zero_point);

        $for C in range(CHANNEL_TILE):
          vfpacc${C} = ${MIN_F32}(vfpacc${C}, voutput_max_less_zero_point);

        $for C in range(CHANNEL_TILE):
          vfpacc${C} += vmagic_bias;

        $for C in range(CHANNEL_TILE):
          int32_t vout${C} = (int32_t) fp32_to_bits(vfpacc${C}) - vmagic_bias_less_output_zero_point;
      $elif VARIANT == "IMAGIC":
        $for C in range(CHANNEL_TILE):
          vfpacc${C} += vmagic_bias;

        $for C in range(CHANNEL_TILE):
          int32_t vout${C} = (int32_t) fp32_to_bits(vfpacc${C});

        $for C in range(CHANNEL_TILE):
          vout${C} = math_max_s32(vout${C}, vmagic_min);

        $for C in range(CHANNEL_TILE):
          vout${C} = math_min_s32(vout${C}, vmagic_max);

        $for C in range(CHANNEL_TILE):
          vout${C} -= vmagic_bias_less_zero_point;
      $elif VARIANT == "LRINTF":
        $for C in range(CHANNEL_TILE):
          vfpacc${C} = ${MAX_F32}(vfpacc${C}, voutput_min_less_zero_point);

        $for C in range(CHANNEL_TILE):
          vfpacc${C} = ${MIN_F32}(vfpacc${C}, voutput_max_less_zero_point);

        $for C in range(CHANNEL_TILE):
          const int32_t vrndacc${C} = (int32_t) lrintf(vfpacc${C});

        $for C in range(CHANNEL_TILE):
          int32_t vout${C} = vrndacc${C} + voutput_zero_point;

      $for C in range(CHANNEL_TILE):
        output[${C}] = (int8_t) vout${C};
      output += ${CHANNEL_TILE};
    }
    if XNN_UNLIKELY(channels != 0) {
      $if CHANNEL_TILE == 2:
        $for M in range(ROW_SUBTILE):
          const int32_t vi${M} = *i${M};

        $for A in range(ACCUMULATORS):
          int32_t vacc${A} = vi${A*2} + vi${A*2+1};

        $for M in range(ACCUMULATORS * 2, ROW_SUBTILE):
          vacc${M % ACCUMULATORS} += vi${M};

        $if ACCUMULATORS > 1:
          $ACC_SLICE = 1
          $while ACC_SLICE < ACCUMULATORS:
            $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
              $if A + ACC_SLICE < ACCUMULATORS:
                vacc${A} += vacc${A + ACC_SLICE};
            $ACC_SLICE *= 2

        const int32_t vacc = *buffer + vacc0;
        float vfpacc = (float) vacc * vscale;

        $if VARIANT == "FMAGIC":
          vfpacc = ${MAX_F32}(vfpacc, voutput_min_less_zero_point);
          vfpacc = ${MIN_F32}(vfpacc, voutput_max_less_zero_point);
          vfpacc += vmagic_bias;
          int32_t vout = (int32_t) fp32_to_bits(vfpacc) - vmagic_bias_less_output_zero_point;
        $elif VARIANT == "IMAGIC":
          vfpacc += vmagic_bias;
          int32_t vout = (int32_t) fp32_to_bits(vfpacc);
          vout = math_max_s32(vout, vmagic_min);
          vout = math_min_s32(vout, vmagic_max);
          vout -= vmagic_bias_less_zero_point;
        $elif VARIANT == "LRINTF":
          vfpacc = ${MAX_F32}(vfpacc, voutput_min_less_zero_point);
          vfpacc = ${MIN_F32}(vfpacc, voutput_max_less_zero_point);
          const int32_t vrndacc = (int32_t) lrintf(vfpacc);
          int32_t vout = vrndacc + voutput_zero_point;

        *output = (int8_t) vout;
      $else:
        do {
          $for M in range(ROW_SUBTILE):
            const int32_t vi${M} = *i${M}++;

          $for A in range(ACCUMULATORS):
            int32_t vacc${A} = vi${A*2} + vi${A*2+1};

          $for M in range(ACCUMULATORS * 2, ROW_SUBTILE):
            vacc${M % ACCUMULATORS} += vi${M};

          $if ACCUMULATORS > 1:
            $ACC_SLICE = 1
            $while ACC_SLICE < ACCUMULATORS:
              $for A in range(0, ACCUMULATORS, ACC_SLICE * 2):
                $if A + ACC_SLICE < ACCUMULATORS:
                  vacc${A} += vacc${A + ACC_SLICE};
              $ACC_SLICE *= 2

          const int32_t vacc = (*buffer++) + vacc0;
          float vfpacc = (float) vacc * vscale;

          $if VARIANT == "FMAGIC":
            vfpacc = ${MAX_F32}(vfpacc, voutput_min_less_zero_point);
            vfpacc = ${MIN_F32}(vfpacc, voutput_max_less_zero_point);
            vfpacc += vmagic_bias;
            int32_t vout = (int32_t) fp32_to_bits(vfpacc) - vmagic_bias_less_output_zero_point;
          $elif VARIANT == "IMAGIC":
            vfpacc += vmagic_bias;
            int32_t vout = (int32_t) fp32_to_bits(vfpacc);
            vout = math_max_s32(vout, vmagic_min);
            vout = math_min_s32(vout, vmagic_max);
            vout -= vmagic_bias_less_zero_point;
          $elif VARIANT == "LRINTF":
            vfpacc = ${MAX_F32}(vfpacc, voutput_min_less_zero_point);
            vfpacc = ${MIN_F32}(vfpacc, voutput_max_less_zero_point);
            const int32_t vrndacc = (int32_t) lrintf(vfpacc);
            int32_t vout = vrndacc + voutput_zero_point;

          *output++ = (int8_t) vout;
        } while (--channels != 0);
    }
}
